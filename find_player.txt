int key_press(int keycode, t_game *game)
{
    if (keycode == 65307) // ESC key
    {
        mlx_destroy_window(game->mlx, game->mlx_win);
        exit(0);
    }
    if (keycode == 119 || keycode == 65362) // W key ola UP arrow
    {
        // Move forward
        double new_x = game->player->x + game->player->dir_x * game->player->move_speed;
        double new_y = game->player->y + game->player->dir_y * game->player->move_speed;
        
        // Check collision m3a walls
        if (game->data->map[(int)new_y][(int)new_x] != '1')
        {
            game->player->x = new_x;
            game->player->y = new_y;
        }
    }
    if (keycode == 115 || keycode == 65364) // S key ola DOWN arrow
    {
        // Move backward
        double new_x = game->player->x - game->player->dir_x * game->player->move_speed;
        double new_y = game->player->y - game->player->dir_y * game->player->move_speed;
        
        if (game->data->map[(int)new_y][(int)new_x] != '1')
        {
            game->player->x = new_x;
            game->player->y = new_y;
        }
    }
    if (keycode == 97 || keycode == 65361) // A key ola LEFT arrow
    {
        // Rotate left
        double old_dir_x = game->player->dir_x;
        game->player->dir_x = game->player->dir_x * cos(game->player->rot_speed) - game->player->dir_y * sin(game->player->rot_speed);
        game->player->dir_y = old_dir_x * sin(game->player->rot_speed) + game->player->dir_y * cos(game->player->rot_speed);
        
        double old_plane_x = game->player->plane_x;
        game->player->plane_x = game->player->plane_x * cos(game->player->rot_speed) - game->player->plane_y * sin(game->player->rot_speed);
        game->player->plane_y = old_plane_x * sin(game->player->rot_speed) + game->player->plane_y * cos(game->player->rot_speed);
    }
    if (keycode == 100 || keycode == 65363) // D key ola RIGHT arrow
    {
        // Rotate right
        double old_dir_x = game->player->dir_x;
        game->player->dir_x = game->player->dir_x * cos(-game->player->rot_speed) - game->player->dir_y * sin(-game->player->rot_speed);
        game->player->dir_y = old_dir_x * sin(-game->player->rot_speed) + game->player->dir_y * cos(-game->player->rot_speed);
        
        double old_plane_x = game->player->plane_x;
        game->player->plane_x = game->player->plane_x * cos(-game->player->rot_speed) - game->player->plane_y * sin(-game->player->rot_speed);
        game->player->plane_y = old_plane_x * sin(-game->player->rot_speed) + game->player->plane_y * cos(-game->player->rot_speed);
    }
    
    // Redraw la scene ba3d kol movement
    mlx_clear_window(game->mlx, game->mlx_win);
    draw_mini_map(game);
    
    return (0);
}






///// frame rate independent movement

// F main loop
double oldTime = 0;
double currentTime = 0;

while (game_running)
{
    currentTime = get_current_time();  // Fonction li traja3 l time
    double frameTime = (currentTime - oldTime) / 1000.0;  // Convertir l seconds
    oldTime = currentTime;
    
    double moveSpeed = 5.0 * frameTime;      // 5.0 = vitesse de base
    double rotSpeed = 3.0 * frameTime;       // 3.0 = rotation de base
    
    // Appliquer l mouvement
    handle_movement(moveSpeed, rotSpeed);
}