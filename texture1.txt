#include "cub3d.h"

int    ft_isspace(int c)
{
    return (c == ' ' || c == '\t' || c == '\n' 
            || c == '\v' || c == '\f' || c == '\r');
}

int is_empty_line(char *line)
{
    int i;
    
    i = 0;
    while (line[i])
    {
        if (!ft_isspace(line[i]))
            return (0);
        i++;
    }
    return (1);
}

int is_map_line(char *line)
{
    int i;
    
    i = 0;
    while (line[i])
    {
        if (!ft_strchr("01NSEW ", line[i]))
            return (0);
        i++;
    }
    return (1);
}

void error_exit(char *message)
{
    printf("%s\n", message);
    exit(1);
}

void    validate_map(t_data *data)
{
    int i;
    int j;

    // Vérifier que la map est fermée
    i = 0;
    while (i < data->map_height)
    {
        j = 0;
        while (j < (int)ft_strlen(data->map[i]))
        {
            if (data->map[i][j] == '0' || ft_strchr("NSEW", data->map[i][j]))
            {
                // Vérifier les cases autour
                if (i == 0 || j == 0 || i == data->map_height - 1 || 
                    j == (int)ft_strlen(data->map[i]) - 1 ||
                    data->map[i-1][j] == ' ' || data->map[i+1][j] == ' ' ||
                    data->map[i][j-1] == ' ' || data->map[i][j+1] == ' ')
                {
                    error_exit("Error: Map is not closed");
                }
            }
            j++;
        }
        i++;
    }
    
    // Vérifier qu'il y a un joueur
    if (data->player_x == 0 && data->player_y == 0)
        error_exit("Error: No player position");
}

void free_split(char **split)
{
    int i = 0;

    if (!split)
        return;

    while (split[i])
    {
        free(split[i]);
        i++;
    }
    free(split);
}

int parse_color(char *str)
{
    char    **rgb;
    int     r;
    int     g;
    int     b;
    
    // Séparer les valeurs RGB
    rgb = ft_split(str, ',');
    if (!rgb || !rgb[0] || !rgb[1] || !rgb[2] || rgb[3])
        error_exit("Error: Invalid color format");
    
    // Convertir en integers
    r = ft_atoi(rgb[0]);
    g = ft_atoi(rgb[1]);
    b = ft_atoi(rgb[2]);
    
    // Vérifier les valeurs
    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255)
        error_exit("Error: Color values out of range");
    
    // Nettoyer et retourner la couleur
    free_split(rgb);
    return (r << 16 | g << 8 | b);
}

void    parse_map_line(char *line, t_data *data)
{
    static int  map_started = 0;
    static int  index = 0;
    // char        **temp;
    int         i;

    // Allouer/redimensionner le tableau de map
    if (!map_started)
    {
        data->map = malloc(sizeof(char *) * 100); // Tu peux adapter la taille
        map_started = 1;
    }
    
    data->map[index] = ft_strdup(line);
    index++;
    data->map_height = index;
    
    // Trouver la largeur maximale
    if ((int)ft_strlen(line) > data->map_width)
        data->map_width = ft_strlen(line);
    
    // Trouver la position du joueur
    i = 0;
    while (line[i])
    {
        if (ft_strchr("NSEW", line[i]))
        {
            if (data->player_x != 0 || data->player_y != 0)
                error_exit("Error: Multiple player positions");
            data->player_x = i;
            data->player_y = index - 1;
            data->player_dir = line[i];
        }
        i++;
    }
}

void    parse_config_line(char *line, t_data *data)
{
    // Textures
    if (ft_strncmp(line, "NO ", 3) == 0)
        data->no_path = ft_strtrim(line + 3, " ");
    else if (ft_strncmp(line, "SO ", 3) == 0)
        data->so_path = ft_strtrim(line + 3, " ");
    else if (ft_strncmp(line, "WE ", 3) == 0)
        data->we_path = ft_strtrim(line + 3, " ");
    else if (ft_strncmp(line, "EA ", 3) == 0)
        data->ea_path = ft_strtrim(line + 3, " ");
    
    // Couleurs
    else if (ft_strncmp(line, "F ", 2) == 0)
        data->floor_color = parse_color(line + 2);
    else if (ft_strncmp(line, "C ", 2) == 0)
        data->ceiling_color = parse_color(line + 2);
    else
        error_exit("Error: Invalid configuration line");
}

void    parse_cub_file(char *filename, t_data *data)
{
    int     fd;
    char    *line;
    int     reading_map;

    fd = open(filename, O_RDONLY);
    if (fd < 0)
        error_exit("Error: Can't open file");
    
    reading_map = 0;
    while ((line = get_next_line(fd)) != NULL)
    {
        // Ignorer les lignes vides
        if (is_empty_line(line))
        {
            free(line);
            continue;
        }
        
        // Vérifier si on est dans la map
        if (is_map_line(line) || reading_map)
        {
            reading_map = 1;
            parse_map_line(line, data);
        }
        else
        {
            parse_config_line(line, data);
        }
        
        free(line);
    }
    close(fd);
    
    // Validation finale
    validate_map(data);
}