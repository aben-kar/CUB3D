# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    raycasting.txt                                     :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: achraf <achraf@student.42.fr>              +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/09/29 16:50:00 by achraf            #+#    #+#              #
#    Updated: 2025/09/29 16:44:25 by achraf           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "cub3d.h"

void my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
    char *dst;

    if (x >= 0 && x < SCREEN_WIDTH && y >= 0 && y < SCREEN_HEIGHT)
    {
        dst = data->game.addr + (y * data->game.line_length + x * (data->game.bits_per_pixel / 8));
        *(unsigned int*)dst = color;
    }
}

void draw_vertical_line(t_data *data, int x, int start, int end, int color)
{
    int y;
    
    y = start;
    while (y <= end)
    {
        my_mlx_pixel_put(data, x, y, color);
        y++;
    }
}

void raycasting(t_data *data)
{
    int x;
    
    x = 0;
    while (x < SCREEN_WIDTH)
    {
        // Calculate ray position and direction
        double camera_x = 2 * x / (double)SCREEN_WIDTH - 1;
        double ray_dir_x = data->player.dir_x + data->player.plane_x * camera_x;
        double ray_dir_y = data->player.dir_y + data->player.plane_y * camera_x;
        
        // Which box of the map we're in
        int map_x = (int)data->player.x;
        int map_y = (int)data->player.y;
        
        // Length of ray from current position to x or y side
        double delta_dist_x, delta_dist_y;
        
        if (ray_dir_x == 0)
            delta_dist_x = 1e30;
        else
            delta_dist_x = fabs(1 / ray_dir_x);
        
        if (ray_dir_y == 0)
            delta_dist_y = 1e30;
        else
            delta_dist_y = fabs(1 / ray_dir_y);
        
        double perp_wall_dist;
        
        // Calculate step and initial side_dist
        int step_x, step_y;
        double side_dist_x, side_dist_y;
        
        if (ray_dir_x < 0)
        {
            step_x = -1;
            side_dist_x = (data->player.x - map_x) * delta_dist_x;
        }
        else
        {
            step_x = 1;
            side_dist_x = (map_x + 1.0 - data->player.x) * delta_dist_x;
        }
        
        if (ray_dir_y < 0)
        {
            step_y = -1;
            side_dist_y = (data->player.y - map_y) * delta_dist_y;
        }
        else
        {
            step_y = 1;
            side_dist_y = (map_y + 1.0 - data->player.y) * delta_dist_y;
        }
        
        // Perform DDA
        int hit = 0;
        int side; // 0 if x-side, 1 if y-side
        
        while (hit == 0)
        {
            // Jump to next map square, either in x-direction, or in y-direction
            if (side_dist_x < side_dist_y)
            {
                side_dist_x += delta_dist_x;
                map_x += step_x;
                side = 0;
            }
            else
            {
                side_dist_y += delta_dist_y;
                map_y += step_y;
                side = 1;
            }
            
            // Check if ray has hit a wall
            if (data->map[map_y][map_x] == '1')
                hit = 1;
        }
        
        // Calculate distance
        if (side == 0)
            perp_wall_dist = (map_x - data->player.x + (1 - step_x) / 2) / ray_dir_x;
        else
            perp_wall_dist = (map_y - data->player.y + (1 - step_y) / 2) / ray_dir_y;
        
        // Calculate height of line to draw on screen
        int line_height = (int)(SCREEN_HEIGHT / perp_wall_dist);
        
        // Calculate lowest and highest pixel to fill in current stripe
        int draw_start = -line_height / 2 + SCREEN_HEIGHT / 2;
        if (draw_start < 0)
            draw_start = 0;
        
        int draw_end = line_height / 2 + SCREEN_HEIGHT / 2;
        if (draw_end >= SCREEN_HEIGHT)
            draw_end = SCREEN_HEIGHT - 1;
        
        // Choose wall color based on direction
        int color;
        if (side == 1)
        {
            // North or South wall
            if (ray_dir_y > 0)
                color = 0xFF0000; // Red for South
            else
                color = 0x00FF00; // Green for North
        }
        else
        {
            // East or West wall
            if (ray_dir_x > 0)
                color = 0x0000FF; // Blue for East
            else
                color = 0xFFFF00; // Yellow for West
        }
        
        // Make wall darker if it's a y-side
        if (side == 1)
            color = color / 2;
        
        // Draw the wall
        draw_vertical_line(data, x, draw_start, draw_end, color);
        
        // Draw floor
        draw_vertical_line(data, x, draw_end + 1, SCREEN_HEIGHT - 1, data->floor_color);
        
        // Draw ceiling
        draw_vertical_line(data, x, 0, draw_start - 1, data->ceiling_color);
        
        x++;
    }
}

void render_frame(t_data *data)
{
    // Clear the image
    int x, y;
    
    y = 0;
    while (y < SCREEN_HEIGHT)
    {
        x = 0;
        while (x < SCREEN_WIDTH)
        {
            my_mlx_pixel_put(data, x, y, 0x000000);
            x++;
        }
        y++;
    }
    
    // Perform raycasting
    raycasting(data);
    
    // Put image to window
    mlx_put_image_to_window(data->game.mlx, data->game.win, data->game.img, 0, 0);
}